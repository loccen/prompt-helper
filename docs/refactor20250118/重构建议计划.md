# Prompt-Helper 重构建议计划

## 一、重构目标

本次重构计划的主要目标是在已有架构基础上，进一步提升 Prompt-Helper 项目的代码质量、性能和用户体验。具体目标包括：

1. **提高代码可维护性**：通过优化组件结构和职责划分，降低代码复杂度
2. **增强系统稳定性**：完善错误处理和异步操作管理
3. **提升系统性能**：优化资源使用和处理效率
4. **改善用户体验**：提高响应速度和交互流畅度
5. **增强可测试性**：完善测试框架和测试覆盖率

## 二、重构前置工作：测试覆盖率提升

在开始实际的重构工作前，必须先建立充分的测试安全网，确保重构过程中不会破坏现有功能。这是重构成功的关键前提。

### 测试框架建设（2人日）

**目标**：建立统一的测试框架和最佳实践

**具体任务**：
- 建立核心服务和组件的测试模式
  ```typescript
  // 建立测试工具和辅助函数
  export class TestUtils {
    // 创建模拟的扩展上下文
    public static createMockExtensionContext(): vscode.ExtensionContext {
      return {
        subscriptions: [],
        extensionPath: '/fake/path',
        extensionUri: vscode.Uri.parse('file:///fake/path'),
        storagePath: '/fake/storage',
        globalStoragePath: '/fake/global-storage',
        logPath: '/fake/log',
        workspaceState: {
          get: jest.fn(),
          update: jest.fn().mockResolvedValue(undefined)
        } as any,
        globalState: {
          get: jest.fn(),
          update: jest.fn().mockResolvedValue(undefined)
        } as any,
        asAbsolutePath: jest.fn().mockImplementation(p => `/fake/path/${p}`)
      } as any;
    }
    
    // 创建模拟的文件系统
    public static createMockFileSystem(files: Record<string, string>): any {
      return {
        existsSync: jest.fn().mockImplementation(path => !!files[path]),
        readdirSync: jest.fn().mockImplementation(() => Object.keys(files).map(f => path.basename(f))),
        readFileSync: jest.fn().mockImplementation(path => files[path] || '')
      };
    }
    
    // 其他测试辅助方法...
  }
  ```

- 实现模拟对象和存根
  ```typescript
  // 模拟 PromptService
  export class MockPromptService implements PromptService {
    private roles: IPromptRole[] = [];
    
    constructor(mockRoles: IPromptRole[] = []) {
      this.roles = mockRoles;
    }
    
    public getRoles(): IPromptRole[] {
      return this.roles;
    }
    
    public async getPromptContent(roleId: string): Promise<string> {
      const role = this.roles.find(r => r.id === roleId);
      return role ? `Mock content for ${role.name}` : '';
    }
    
    // 其他方法实现...
  }
  ```

- 配置 Jest 测试环境
  ```javascript
  // jest.config.js
  module.exports = {
    preset: 'ts-jest',
    testEnvironment: 'node',
    testMatch: ['**/tests/**/*.test.ts'],
    collectCoverage: true,
    collectCoverageFrom: [
      'src/**/*.ts',
      '!src/test/**',
      '!**/node_modules/**'
    ],
    coverageReporters: ['text', 'lcov', 'html'],
    coverageThreshold: {
      global: {
        branches: 70,
        functions: 80,
        lines: 80,
        statements: 80
      }
    }
  };
  ```

### 核心服务测试实现（3人日）

**目标**：为关键服务建立完整的单元测试

**具体任务**：
- 为 `PromptService` 编写测试
  ```typescript
  describe('PromptService', () => {
    let service: PromptService;
    let mockFs: any;
    let mockPath: string;
    
    beforeEach(() => {
      mockPath = '/fake/path';
      mockFs = TestUtils.createMockFileSystem({
        '/fake/path/prompts/roles/test-role.md': '# Test Role\n\n## 角色描述\n\nTest description',
        '/fake/path/prompts/roles/another-role.md': '# Another Role\n\n## 角色描述\n\nAnother description'
      });
      
      service = new PromptService(mockPath, mockFs);
    });
    
    test('should load roles correctly', () => {
      const roles = service.getRoles();
      expect(roles.length).toBe(2);
      expect(roles[0].name).toBe('Test Role');
      expect(roles[1].name).toBe('Another Role');
    });
    
    test('should get prompt content', async () => {
      const content = await service.getPromptContent('test-role');
      expect(content).toContain('Test Role');
      expect(content).toContain('Test description');
    });
    
    test('should handle missing role', async () => {
      await expect(service.getPromptContent('non-existent')).rejects.toThrow();
    });
    
    // 更多测试...
  });
  ```

- 为 `WorkflowService` 编写测试
  ```typescript
  describe('WorkflowService', () => {
    let service: WorkflowService;
    let mockFs: any;
    
    beforeEach(() => {
      mockFs = TestUtils.createMockFileSystem({
        '/fake/path/prompts/workflows.json': JSON.stringify({
          workflows: [
            {
              id: 'test-workflow',
              name: 'Test Workflow',
              description: 'A test workflow',
              steps: [
                {
                  id: 'step1',
                  name: 'Step 1',
                  role: 'test-role',
                  description: 'First step'
                }
              ]
            }
          ]
        })
      });
      
      service = new WorkflowService('/fake/path', mockFs);
    });
    
    test('should load workflows correctly', () => {
      const workflows = service.getWorkflows();
      expect(workflows.length).toBe(1);
      expect(workflows[0].id).toBe('test-workflow');
      expect(workflows[0].steps.length).toBe(1);
    });
    
    // 更多测试...
  });
  ```

- 为 `FlowStateManager` 编写测试
  ```typescript
  describe('FlowStateManager', () => {
    let stateManager: FlowStateManager;
    let mockContext: vscode.ExtensionContext;
    
    beforeEach(() => {
      mockContext = TestUtils.createMockExtensionContext();
      stateManager = new FlowStateManager(mockContext);
    });
    
    test('should initialize with empty state', () => {
      expect(stateManager.state.flowId).toBe('');
      expect(stateManager.state.currentStepIndex).toBe(0);
      expect(stateManager.state.completedSteps).toEqual([]);
    });
    
    test('should update flow state', () => {
      stateManager.updateState({
        flowId: 'test-flow',
        currentStepIndex: 1,
        completedSteps: ['step1'],
        projectContext: { userIdea: 'Test idea' }
      });
      
      expect(stateManager.state.flowId).toBe('test-flow');
      expect(stateManager.state.currentStepIndex).toBe(1);
      expect(stateManager.state.completedSteps).toContain('step1');
      expect(stateManager.state.projectContext.userIdea).toBe('Test idea');
    });
    
    // 更多测试...
  });
  ```

### UI 组件测试实现（3人日）

**目标**：为关键 UI 组件建立测试

**具体任务**：
- 为树视图提供者编写测试
  ```typescript
  describe('PromptTreeProvider', () => {
    let provider: PromptTreeProvider;
    let mockPromptService: MockPromptService;
    
    beforeEach(() => {
      mockPromptService = new MockPromptService([
        {
          id: 'role1',
          name: 'Role 1',
          description: 'Description 1',
          filePath: '/fake/path/role1.md',
          category: 'Category A',
          sortKey: '01'
        },
        {
          id: 'role2',
          name: 'Role 2',
          description: 'Description 2',
          filePath: '/fake/path/role2.md',
          category: 'Category B',
          sortKey: '02'
        }
      ]);
      
      provider = new PromptTreeProvider(mockPromptService);
    });
    
    test('should group roles by category', async () => {
      const rootItems = await provider.getChildren();
      expect(rootItems.length).toBe(2); // 两个分类
      
      const categoryA = rootItems[0];
      expect(categoryA.label).toBe('Category A');
      
      const rolesInCategoryA = await provider.getChildren(categoryA);
      expect(rolesInCategoryA.length).toBe(1);
      expect(rolesInCategoryA[0].label).toBe('Role 1');
    });
    
    // 更多测试...
  });
  ```

- 为 DevFlowGuideProvider 编写基础测试
  ```typescript
  describe('DevFlowGuideProvider', () => {
    let provider: DevFlowGuideProvider;
    let mockPromptService: MockPromptService;
    let mockWorkflowService: MockWorkflowService;
    let mockWebviewView: any;
    let mockContext: vscode.ExtensionContext;
    
    beforeEach(() => {
      mockPromptService = new MockPromptService();
      mockWorkflowService = new MockWorkflowService();
      mockContext = TestUtils.createMockExtensionContext();
      
      mockWebviewView = {
        webview: {
          options: {},
          html: '',
          onDidReceiveMessage: jest.fn(),
          postMessage: jest.fn().mockResolvedValue(true)
        }
      };
      
      provider = new DevFlowGuideProvider(
        mockContext.extensionUri,
        mockPromptService,
        mockWorkflowService,
        mockContext
      );
    });
    
    test('should initialize correctly', () => {
      provider.resolveWebviewView(mockWebviewView as any);
      expect(mockWebviewView.webview.options.enableScripts).toBe(true);
      expect(mockWebviewView.webview.html).not.toBe('');
    });
    
    // 测试消息处理
    test('should handle startFlow message', async () => {
      // 设置 webview 和模拟消息
      provider.resolveWebviewView(mockWebviewView as any);
      
      // 找到注册的消息处理函数
      const messageHandler = mockWebviewView.webview.onDidReceiveMessage.mock.calls[0][0];
      
      // 调用消息处理函数
      await messageHandler({ command: 'startFlow', flowId: 'test-flow' });
      
      // 验证结果
      expect(mockWebviewView.webview.postMessage).toHaveBeenCalled();
    });
    
    // 更多测试...
  });
  ```

## 三、重构任务分解

完成测试基础设施和关键组件的测试覆盖后，可以开始实际的重构工作。

### 阶段一：核心架构优化（估计工作量：7.5人日）

#### 1. DevFlowGuideProvider 组件拆分（3人日）

**目标**：将现有 DevFlowGuideProvider 进一步拆分为职责更加单一的组件

**具体任务**：
- 创建 `MessageHandler` 类处理 WebView 消息
  ```typescript
  export class DevFlowMessageHandler {
    constructor(
      private readonly stateManager: FlowStateManager,
      private readonly workflowService: WorkflowService,
      private readonly promptService: PromptService
    ) {}
    
    public async handleMessage(message: any): Promise<void> {
      switch (message.command) {
        case 'startFlow':
          return this.handleStartFlow(message.flowId);
        case 'nextStep':
          return this.handleNextStep();
        // 其他消息处理...
      }
    }
    
    private async handleStartFlow(flowId: string): Promise<void> {
      // 实现启动流程逻辑
    }
    
    // 其他私有方法...
  }
  ```

- 创建 `FlowController` 类管理流程状态转换
  ```typescript
  export class FlowController {
    constructor(
      private readonly stateManager: FlowStateManager,
      private readonly mappingService: FlowStepsMappingService
    ) {}
    
    public async moveToNextStep(): Promise<void> {
      // 实现步骤转换逻辑
    }
    
    public async moveToPrevStep(): Promise<void> {
      // 实现步骤转换逻辑
    }
    
    // 其他方法...
  }
  ```

- 重构 DevFlowGuideProvider 专注于视图控制

#### 2. 统一错误处理机制（2人日）

**目标**：建立统一的错误处理框架，提高错误处理的一致性和友好性

**具体任务**：
- 创建 `ErrorManager` 类
  ```typescript
  export enum ErrorSeverity {
    INFO,
    WARNING,
    ERROR,
    CRITICAL
  }
  
  export class ErrorManager {
    private static instance: ErrorManager;
    
    public static getInstance(): ErrorManager {
      if (!ErrorManager.instance) {
        ErrorManager.instance = new ErrorManager();
      }
      return ErrorManager.instance;
    }
    
    public handleError(error: any, context: string, severity: ErrorSeverity = ErrorSeverity.ERROR): void {
      // 错误处理逻辑
    }
    
    public logError(error: any, context: string): void {
      // 日志记录逻辑
    }
    
    public showErrorToUser(message: string, severity: ErrorSeverity): void {
      // 用户显示逻辑
    }
  }
  ```

- 定义自定义错误类型
  ```typescript
  export class PromptHelperError extends Error {
    constructor(
      message: string,
      public readonly context: string,
      public readonly severity: ErrorSeverity = ErrorSeverity.ERROR,
      public readonly originalError?: any
    ) {
      super(message);
      this.name = 'PromptHelperError';
    }
  }
  ```

- 在所有组件中统一使用新的错误处理机制

#### 3. 异步流程管理优化（2.5人日）

**目标**：改进异步操作的管理和状态跟踪

**具体任务**：
- 创建 `AsyncTaskManager` 类
  ```typescript
  export class AsyncTaskManager {
    private tasks: Map<string, {
      promise: Promise<any>;
      cancel?: () => void;
    }> = new Map();
    
    public async executeTask<T>(
      taskId: string,
      task: () => Promise<T>,
      options?: {
        timeout?: number;
        onProgress?: (progress: number) => void;
      }
    ): Promise<T> {
      // 任务执行逻辑
    }
    
    public cancelTask(taskId: string): boolean {
      // 任务取消逻辑
    }
    
    public isTaskRunning(taskId: string): boolean {
      return this.tasks.has(taskId);
    }
  }
  ```

- 实现标准化的加载状态管理
  ```typescript
  export class LoadingStateManager {
    private loadingStates: Map<string, boolean> = new Map();
    private listeners: Map<string, ((isLoading: boolean) => void)[]> = new Map();
    
    public setLoading(operationId: string, isLoading: boolean): void {
      // 设置加载状态
    }
    
    public isLoading(operationId: string): boolean {
      return this.loadingStates.get(operationId) || false;
    }
    
    // 事件监听方法...
  }
  ```

- 集成到现有组件中

### 阶段二：性能和体验优化（估计工作量：8.5人日）

#### 1. HTML生成器重构（4人日）

**目标**：优化 HTML 生成过程，提高效率和可维护性

**具体任务**：
- 设计基于组件的 HTML 生成系统
  ```typescript
  export interface IHtmlComponent {
    render(): string;
  }
  
  export class HtmlComponentBase implements IHtmlComponent {
    constructor(
      protected readonly props: Record<string, any> = {}
    ) {}
    
    public render(): string {
      // 基础渲染逻辑
    }
  }
  ```

- 实现关键UI组件
  ```typescript
  export class StepNavigator extends HtmlComponentBase {
    public render(): string {
      // 步骤导航渲染逻辑
    }
  }
  
  export class StepContent extends HtmlComponentBase {
    public render(): string {
      // 步骤内容渲染逻辑
    }
  }
  ```

- 创建组件工厂和渲染管道
- 实现增量更新机制，避免不必要的完整页面刷新

#### 2. 缓存机制实现（2.5人日）

**目标**：减少重复数据获取和处理，提高响应速度

**具体任务**：
- 创建 `CacheManager` 类
  ```typescript
  export class CacheManager<T> {
    private cache: Map<string, {
      data: T;
      timestamp: number;
    }> = new Map();
    
    constructor(
      private readonly ttl: number = 1000 * 60 * 5 // 默认5分钟
    ) {}
    
    public set(key: string, data: T): void {
      // 设置缓存
    }
    
    public get(key: string): T | null {
      // 获取缓存
    }
    
    public has(key: string): boolean {
      // 检查缓存
    }
    
    public invalidate(key: string): void {
      // 使缓存失效
    }
    
    public clear(): void {
      // 清除所有缓存
    }
  }
  ```

- 为文件操作添加缓存层
  ```typescript
  export class CachedFileReader {
    private cache: CacheManager<string> = new CacheManager(1000 * 60 * 30); // 30分钟缓存
    
    public async readFile(path: string): Promise<string> {
      // 带缓存的文件读取逻辑
    }
  }
  ```

- 集成到 PromptService 和 WorkflowService 中

#### 3. 配置管理统一（2人日）

**目标**：实现统一的配置管理，支持运行时配置调整

**具体任务**：
- 创建 `ConfigurationService` 类
  ```typescript
  export class ConfigurationService {
    private config: Map<string, any> = new Map();
    private listeners: Array<(key: string, value: any) => void> = [];
    
    constructor(
      private readonly extensionContext: vscode.ExtensionContext
    ) {
      this.loadConfiguration();
    }
    
    public get<T>(key: string, defaultValue?: T): T {
      // 获取配置
    }
    
    public set<T>(key: string, value: T): void {
      // 设置配置
    }
    
    // 其他方法...
  }
  ```

- 实现配置变更通知机制
- 支持用户自定义配置
- 将所有现有配置迁移到新的配置服务

### 阶段三：用户体验与持续测试（估计工作量：10.5人日）

#### 1. WebView性能优化（3人日）

**目标**：提高 WebView 的渲染效率和响应速度

**具体任务**：
- 实现虚拟滚动
  ```typescript
  // 在 HTML 模板中添加虚拟滚动实现
  const script = `
  class VirtualScroller {
    constructor(container, itemHeight, renderItem) {
      this.container = container;
      this.itemHeight = itemHeight;
      this.renderItem = renderItem;
      this.items = [];
      this.visibleItems = [];
      this.setupScroller();
    }
    
    setupScroller() {
      // 虚拟滚动实现
    }
    
    // 其他方法...
  }
  `;
  ```

- 优化资源加载顺序
  ```typescript
  // 实现关键资源优先加载
  const html = `
  <!DOCTYPE html>
  <html>
  <head>
    <style>
      /* 关键样式 */
    </style>
  </head>
  <body>
    <div id="app">
      <!-- 基础结构 -->
    </div>
    
    <!-- 关键脚本 -->
    <script>
      // 初始化和核心功能
    </script>
    
    <!-- 延迟加载非关键资源 -->
    <script>
      window.addEventListener('load', () => {
        // 加载非关键脚本和样式
      });
    </script>
  </body>
  </html>
  `;
  ```

- 优化DOM操作
- 实现加载状态和过渡动效

#### 2. 用户体验提升（3.5人日）

**目标**：提高用户界面的易用性和视觉反馈

**具体任务**：
- 改进交互设计
  ```typescript
  // 添加更多交互反馈
  const button = `
  <button 
    class="action-button"
    data-action="${action}"
    onclick="this.classList.add('clicked'); setTimeout(() => this.classList.remove('clicked'), 200);"
  >
    ${label}
  </button>
  `;
  ```

- 优化加载状态展示
  ```typescript
  // 实现更友好的加载指示器
  const loadingIndicator = `
  <div class="loading-container ${isLoading ? 'active' : ''}">
    <div class="loading-spinner"></div>
    <div class="loading-message">${message}</div>
  </div>
  `;
  ```

- 优化错误提示
- 增强键盘导航和可访问性

#### 3. 持续测试改进（4人日）

**目标**：继续提高测试覆盖率，确保重构质量

**具体任务**：
- 添加集成测试
  ```typescript
  describe('Integration: WorkflowManagement', () => {
    let promptService: PromptService;
    let workflowService: WorkflowService;
    let stateManager: FlowStateManager;
    let context: vscode.ExtensionContext;
    
    beforeEach(() => {
      context = TestUtils.createMockExtensionContext();
      promptService = new PromptService(context.extensionPath);
      workflowService = new WorkflowService(context.extensionPath);
      stateManager = new FlowStateManager(context);
    });
    
    test('should complete full workflow lifecycle', async () => {
      // 测试完整工作流程生命周期
      const workflows = workflowService.getWorkflows();
      const testWorkflow = workflows[0];
      
      // 启动工作流
      stateManager.updateState({
        flowId: testWorkflow.id,
        currentStepIndex: 0,
        completedSteps: [],
        projectContext: { userIdea: 'Test project' }
      });
      
      // 验证初始状态
      expect(stateManager.state.flowId).toBe(testWorkflow.id);
      expect(stateManager.state.currentStepIndex).toBe(0);
      
      // 移动到下一步
      // ... 完整工作流测试
    });
    
    // 更多集成测试...
  });
  ```

- 实现端到端测试
- 改进测试自动化和CI集成
- 提高测试覆盖率至90%+

## 四、交付物清单

1. **测试基础设施和测试套件**
   - 单元测试框架和工具
   - 核心服务和组件的测试用例
   - 测试覆盖率报告

2. **重构后的源代码**
   - 经过优化的组件和服务
   - 新增的工具类和辅助函数
   - 统一的错误处理和配置管理

3. **文档**
   - 架构文档更新
   - API文档
   - 测试报告
   - 性能评估报告

4. **示例和演示**
   - 重构前后对比
   - 性能测试结果
   - 用户体验改进演示

## 五、时间规划

| 阶段 | 开始时间 | 结束时间 | 总工作量 |
|------|----------|----------|----------|
| 前置：测试覆盖率提升 | 2025-03-18 | 2025-03-21 | 8人日 |
| 一：核心架构优化 | 2025-03-22 | 2025-03-28 | 7.5人日 |
| 二：性能和体验优化 | 2025-03-29 | 2025-04-04 | 8.5人日 |
| 三：用户体验与持续测试 | 2025-04-05 | 2025-04-11 | 10.5人日 |
| 总计 | 2025-03-18 | 2025-04-11 | 34.5人日 |

## 六、成功标准

1. **测试覆盖率指标**
   - 核心服务测试覆盖率达到 90%+
   - 组件测试覆盖率达到 80%+
   - 集成测试覆盖关键用户场景

2. **代码质量指标**
   - 代码复杂度降低 20%
   - 函数平均行数减少 15%
   - 代码重复率降低至 5% 以下

3. **性能指标**
   - WebView 渲染时间减少 40%
   - 文件读取操作减少 60%
   - 内存使用优化 30%

4. **稳定性指标**
   - 已知崩溃和报错减少 90%
   - 所有核心功能有测试覆盖
   - 关键路径覆盖率达到 90%+

5. **用户体验指标**
   - 用户交互响应时间减少 50%
   - 用户界面一致性提高
   - 提示信息可理解性提升

## 七、重构策略

1. **测试驱动重构**
   - 先完善测试，再开始重构
   - 确保每个重构步骤都有测试保障
   - 重构后立即运行测试验证

2. **渐进式重构**
   - 小步快跑，每次只重构一个小组件
   - 保持系统持续可用
   - 频繁集成和测试

3. **特性冻结期**
   - 重构期间暂停新功能开发
   - 专注于改进代码质量
   - 只修复关键bug

4. **持续监控**
   - 建立性能和稳定性基准
   - 监控重构过程中的各项指标
   - 及时调整重构策略

## 八、风险管理

| 风险 | 可能性 | 影响 | 缓解措施 |
|------|--------|------|----------|
| 测试覆盖不足 | 低 | 高 | 前置测试工作，建立全面测试基础设施 |
| 引入新bug | 低 | 高 | 测试驱动开发，增加测试覆盖，小步重构 |
| 重构时间延长 | 中 | 中 | 设置明确里程碑，定期评估 |
| 性能退化 | 低 | 高 | 性能基准测试，持续监控 |
| 用户体验不一致 | 中 | 中 | 用户测试，渐进式发布 |

## 九、团队分工

### 主要角色与职责

1. **测试工程师**
   - 开发测试框架和基础设施
   - 编写单元测试和集成测试
   - 验证功能完整性

2. **重构架构师**
   - 负责整体重构策略
   - 制定架构改进方案
   - 评审关键组件设计

3. **核心开发者**
   - 实现核心组件重构
   - 优化关键性能路径
   - 编写单元测试

4. **用户体验设计师**
   - 优化界面交互
   - 设计加载状态和过渡
   - 提高用户体验一致性

### 工作分配

| 任务 | 负责人 | 支持者 |
|------|--------|--------|
| 测试框架建设 | 测试工程师 | 核心开发者 |
| 核心服务测试 | 测试工程师 | 重构架构师 |
| UI组件测试 | 测试工程师 | 用户体验设计师 |
| DevFlowGuideProvider 拆分 | 核心开发者 | 重构架构师 |
| 错误处理机制 | 重构架构师 | 核心开发者 |
| 异步流程管理 | 核心开发者 | 测试工程师 |
| HTML生成器重构 | 核心开发者 | 用户体验设计师 |
| 缓存机制 | 核心开发者 | 重构架构师 |
| 配置管理 | 重构架构师 | 核心开发者 |
| WebView性能优化 | 核心开发者 | 用户体验设计师 |
| 用户体验提升 | 用户体验设计师 | 核心开发者 |
| 持续测试改进 | 测试工程师 | 核心开发者 |

## 十、结论

本重构计划基于对 Prompt-Helper 项目代码的全面分析，旨在系统性地解决当前存在的问题，提升代码质量、性能和用户体验。该计划特别强调了在重构前建立充分的测试基础设施和测试安全网的重要性，这将确保重构过程的安全性和可控性。

通过采用测试驱动重构的方法，结合渐进式改进和持续监控，我们将在保持系统稳定的同时，实现代码优化目标。重构完成后，Prompt-Helper 将具有更清晰的架构、更高的性能和更好的用户体验，为未来的功能扩展和维护奠定坚实基础。 