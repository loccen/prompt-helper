# Prompt-Helper 测试体系架构完善计划

## 一、测试体系架构概述

### 1.1 测试体系定位与目标

根据重构分析报告，Prompt-Helper 项目当前存在测试覆盖率不足的问题，测试体系架构的完善将成为项目重构的前置工作和基础保障。本测试体系架构旨在：

- 建立全面、可靠的测试安全网，保障重构过程的稳定性
- 提高代码质量，降低缺陷率
- 支持测试驱动开发(TDD)的实践
- 促进组件解耦和架构优化
- 持续验证系统功能和性能

### 1.2 测试层次规划

测试体系将采用金字塔模型，从底层到顶层包括：

1. **单元测试**：针对独立组件和函数进行测试，是测试体系的基础
2. **集成测试**：验证组件间的交互和协作
3. **端到端测试**：验证完整用户场景和工作流
4. **性能测试**：评估系统响应性能和资源使用效率

![测试金字塔](./images/test-pyramid.html)

### 1.3 测试覆盖目标

- 核心服务测试覆盖率：≥90%
- 关键组件测试覆盖率：≥80%
- 用户流程覆盖率：≥90%
- 关键路径覆盖率：≥95%

## 二、测试工具与框架选型

### 2.1 测试框架

考虑到项目当前使用了 Mocha 作为测试框架，但配置较为简单，建议升级为更现代的测试解决方案：

1. **Jest**：作为主要测试框架
   - 零配置支持 TypeScript
   - 内置覆盖率统计
   - 快照测试支持
   - 并行测试执行
   - 良好的模拟和存根支持

2. **Sinon.js**：增强模拟和存根能力
   - 提供 spies、stubs 和 mocks
   - 简化异步测试

### 2.2 测试工具链

1. **VS Code 扩展测试框架**：`@vscode/test-electron`
   - 提供 VS Code 扩展测试环境
   - 支持模拟 VS Code API

2. **代码覆盖率工具**：Jest 内置的 Istanbul
   - 生成详细的覆盖率报告
   - 支持设置覆盖率阈值

3. **测试自动化工具**：GitHub Actions
   - CI/CD 集成
   - 自动运行测试套件
   - 覆盖率报告生成

## 三、测试基础设施建设

### 3.1 测试环境和配置

1. **Jest 配置文件**：创建 `jest.config.js`

```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.test.ts'],
  collectCoverage: true,
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/test/**',
    '!**/node_modules/**'
  ],
  coverageReporters: ['text', 'lcov', 'html'],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['./tests/setup.ts']
};
```

2. **测试脚本配置**：更新 `package.json`

```json
"scripts": {
  "test": "jest",
  "test:watch": "jest --watch",
  "test:coverage": "jest --coverage",
  "test:unit": "jest --testPathPattern=unit",
  "test:integration": "jest --testPathPattern=integration",
  "test:e2e": "jest --testPathPattern=e2e"
}
```

### 3.2 测试工具类实现

1. **测试工具类**：`TestUtils`

```typescript
// src/tests/utils/test-utils.ts
import * as vscode from 'vscode';
import * as path from 'path';

export class TestUtils {
  // 创建模拟的扩展上下文
  public static createMockExtensionContext(): vscode.ExtensionContext {
    return {
      subscriptions: [],
      extensionPath: '/fake/path',
      extensionUri: vscode.Uri.parse('file:///fake/path'),
      storagePath: '/fake/storage',
      globalStoragePath: '/fake/global-storage',
      logPath: '/fake/log',
      workspaceState: {
        get: jest.fn(),
        update: jest.fn().mockResolvedValue(undefined)
      } as any,
      globalState: {
        get: jest.fn(),
        update: jest.fn().mockResolvedValue(undefined)
      } as any,
      asAbsolutePath: jest.fn().mockImplementation(p => `/fake/path/${p}`)
    } as any;
  }
  
  // 创建模拟的文件系统
  public static createMockFileSystem(files: Record<string, string>): any {
    return {
      existsSync: jest.fn().mockImplementation(path => !!files[path]),
      readdirSync: jest.fn().mockImplementation(dir => {
        const dirPrefix = dir.endsWith('/') ? dir : `${dir}/`;
        return Object.keys(files)
          .filter(filepath => filepath.startsWith(dirPrefix))
          .map(filepath => path.basename(filepath));
      }),
      readFileSync: jest.fn().mockImplementation(filepath => files[filepath] || '')
    };
  }
  
  // 创建模拟的 WebView
  public static createMockWebview(): any {
    return {
      onDidReceiveMessage: jest.fn(),
      postMessage: jest.fn().mockResolvedValue(true),
      html: '',
      options: {},
      cspSource: 'https://fake-source'
    };
  }
  
  // 创建模拟的 WebViewView
  public static createMockWebviewView(webview?: any): any {
    return {
      webview: webview || TestUtils.createMockWebview(),
      visible: true,
      onDidChangeVisibility: jest.fn(),
      onDidDispose: jest.fn()
    };
  }
}
```

2. **Mock 对象工厂**：创建各服务的模拟实现

```typescript
// src/tests/mocks/mock-prompt-service.ts
import { IPromptRole, PromptService } from '../../services/prompt-service';

export class MockPromptService implements PromptService {
  private roles: IPromptRole[] = [];
  
  constructor(mockRoles: IPromptRole[] = []) {
    this.roles = mockRoles;
  }
  
  public getRoles(): IPromptRole[] {
    return this.roles;
  }
  
  public async getPromptContent(roleId: string): Promise<string> {
    const role = this.roles.find(r => r.id === roleId);
    if (!role) {
      throw new Error(`Role not found: ${roleId}`);
    }
    return `Mock content for ${role.name}`;
  }
  
  // 实现其他方法...
}
```

```typescript
// src/tests/mocks/mock-workflow-service.ts
import { IWorkflow, WorkflowService } from '../../services/workflow-service';

export class MockWorkflowService implements WorkflowService {
  private workflows: IWorkflow[] = [];
  
  constructor(mockWorkflows: IWorkflow[] = []) {
    this.workflows = mockWorkflows;
  }
  
  public getWorkflows(): IWorkflow[] {
    return this.workflows;
  }
  
  public getWorkflowById(id: string): IWorkflow | undefined {
    return this.workflows.find(w => w.id === id);
  }
  
  // 实现其他方法...
}
```

## 四、单元测试实现计划

### 4.1 核心服务测试

#### 4.1.1 PromptService 测试

```typescript
// src/tests/unit/services/prompt-service.test.ts
import * as path from 'path';
import { PromptService } from '../../../services/prompt-service';
import { TestUtils } from '../../utils/test-utils';

describe('PromptService', () => {
  let service: PromptService;
  let mockFs: any;
  let mockPath: string;
  
  beforeEach(() => {
    mockPath = '/fake/path';
    mockFs = TestUtils.createMockFileSystem({
      '/fake/path/prompts/roles/test-role.md': '# Test Role\n\n## 角色描述\n\nTest description',
      '/fake/path/prompts/roles/another-role.md': '# Another Role\n\n## 角色描述\n\nAnother description'
    });
    
    service = new PromptService(mockPath, mockFs);
  });
  
  test('should load roles correctly', () => {
    const roles = service.getRoles();
    expect(roles.length).toBe(2);
    expect(roles[0].name).toBe('Test Role');
    expect(roles[1].name).toBe('Another Role');
  });
  
  test('should get prompt content', async () => {
    const content = await service.getPromptContent('test-role');
    expect(content).toContain('Test Role');
    expect(content).toContain('Test description');
  });
  
  test('should handle missing role', async () => {
    await expect(service.getPromptContent('non-existent')).rejects.toThrow();
  });
  
  // 添加更多测试用例...
});
```

#### 4.1.2 WorkflowService 测试

```typescript
// src/tests/unit/services/workflow-service.test.ts
import { WorkflowService } from '../../../services/workflow-service';
import { TestUtils } from '../../utils/test-utils';

describe('WorkflowService', () => {
  let service: WorkflowService;
  let mockFs: any;
  
  beforeEach(() => {
    mockFs = TestUtils.createMockFileSystem({
      '/fake/path/prompts/workflows.json': JSON.stringify({
        workflows: [
          {
            id: 'test-workflow',
            name: 'Test Workflow',
            description: 'A test workflow',
            steps: [
              {
                id: 'step1',
                name: 'Step 1',
                role: 'test-role',
                description: 'First step'
              }
            ]
          }
        ]
      })
    });
    
    service = new WorkflowService('/fake/path', mockFs);
  });
  
  test('should load workflows correctly', () => {
    const workflows = service.getWorkflows();
    expect(workflows.length).toBe(1);
    expect(workflows[0].id).toBe('test-workflow');
    expect(workflows[0].steps.length).toBe(1);
  });
  
  test('should get workflow by id', () => {
    const workflow = service.getWorkflowById('test-workflow');
    expect(workflow).toBeDefined();
    expect(workflow?.name).toBe('Test Workflow');
  });
  
  test('should handle non-existent workflow', () => {
    const workflow = service.getWorkflowById('non-existent');
    expect(workflow).toBeUndefined();
  });
  
  // 添加更多测试用例...
});
```

### 4.2 UI 组件测试

#### 4.2.1 FlowStateManager 测试

已有的 flow-state-manager.test.ts 测试较为完善，但应转换为 Jest 风格：

```typescript
// src/tests/unit/ui/webview/flow-state-manager.test.ts
import * as vscode from 'vscode';
import { FlowStateManager } from '../../../../ui/webview/flow-state-manager';
import { TestUtils } from '../../../utils/test-utils';

describe('FlowStateManager', () => {
  let stateManager: FlowStateManager;
  let mockContext: vscode.ExtensionContext;
  
  beforeEach(() => {
    mockContext = TestUtils.createMockExtensionContext();
    stateManager = new FlowStateManager(mockContext);
  });
  
  test('初始状态应该是空的', () => {
    const state = stateManager.state;
    
    expect(state.flowId).toBe('');
    expect(state.currentStepIndex).toBe(0);
    expect(state.projectContext).toEqual({});
    expect(state.completedSteps).toEqual([]);
  });
  
  // 更多测试用例...保留现有的测试用例逻辑
});
```

#### 4.2.2 DevFlowGuideProvider 测试

```typescript
// src/tests/unit/ui/webview/dev-flow-guide-provider.test.ts
import * as vscode from 'vscode';
import { DevFlowGuideProvider } from '../../../../ui/webview/dev-flow-guide-provider';
import { TestUtils } from '../../../utils/test-utils';
import { MockPromptService } from '../../../mocks/mock-prompt-service';
import { MockWorkflowService } from '../../../mocks/mock-workflow-service';
import { FlowStateManager } from '../../../../ui/webview/flow-state-manager';

describe('DevFlowGuideProvider', () => {
  let provider: DevFlowGuideProvider;
  let mockPromptService: MockPromptService;
  let mockWorkflowService: MockWorkflowService;
  let mockWebviewView: any;
  let mockContext: vscode.ExtensionContext;
  let stateManager: FlowStateManager;
  
  beforeEach(() => {
    mockPromptService = new MockPromptService();
    mockWorkflowService = new MockWorkflowService();
    mockContext = TestUtils.createMockExtensionContext();
    mockWebviewView = TestUtils.createMockWebviewView();
    stateManager = new FlowStateManager(mockContext);
    
    provider = new DevFlowGuideProvider(
      mockContext.extensionUri,
      mockPromptService,
      mockWorkflowService,
      mockContext
    );
  });
  
  test('应该正确初始化', () => {
    provider.resolveWebviewView(mockWebviewView as any);
    expect(mockWebviewView.webview.options.enableScripts).toBe(true);
    expect(mockWebviewView.webview.html).not.toBe('');
  });
  
  // 测试消息处理
  test('应该处理startFlow消息', async () => {
    // 设置 webview 和模拟消息
    provider.resolveWebviewView(mockWebviewView as any);
    
    // 找到注册的消息处理函数
    const messageHandler = mockWebviewView.webview.onDidReceiveMessage.mock.calls[0][0];
    
    // 调用消息处理函数
    await messageHandler({ command: 'startFlow', flowId: 'test-flow' });
    
    // 验证结果
    expect(mockWebviewView.webview.postMessage).toHaveBeenCalled();
    
    // 其他验证...
  });
  
  // 更多测试用例...
});
```

### 4.3 工具函数测试

```typescript
// src/tests/unit/utils.test.ts
import { handleError, formatPrompt, /* 其他工具函数 */ } from '../../utils';

describe('Utils', () => {
  describe('handleError', () => {
    const mockShowError = jest.fn();
    const originalWindow = { ...global.vscode?.window };
    
    beforeEach(() => {
      // 模拟 vscode.window.showErrorMessage
      global.vscode = {
        ...global.vscode,
        window: {
          ...global.vscode?.window,
          showErrorMessage: mockShowError
        }
      } as any;
    });
    
    afterEach(() => {
      global.vscode = {
        ...global.vscode,
        window: originalWindow
      } as any;
      jest.clearAllMocks();
    });
    
    test('应该显示错误消息', () => {
      const error = new Error('Test error');
      handleError(error, 'Test context');
      
      expect(mockShowError).toHaveBeenCalledWith(expect.stringContaining('Test error'));
      expect(mockShowError).toHaveBeenCalledWith(expect.stringContaining('Test context'));
    });
    
    // 更多测试用例...
  });
  
  describe('formatPrompt', () => {
    test('应该正确格式化提示词', () => {
      const result = formatPrompt('Test prompt with {placeholder}', { placeholder: 'value' });
      expect(result).toBe('Test prompt with value');
    });
    
    // 更多测试用例...
  });
});
```

## 五、集成测试实现计划

### 5.1 服务层集成测试

```typescript
// src/tests/integration/services-integration.test.ts
import * as vscode from 'vscode';
import { PromptService } from '../../services/prompt-service';
import { WorkflowService } from '../../services/workflow-service';
import { TestUtils } from '../utils/test-utils';

describe('Service Integration', () => {
  let promptService: PromptService;
  let workflowService: WorkflowService;
  let mockContext: vscode.ExtensionContext;
  let mockFs: any;
  
  beforeEach(() => {
    mockContext = TestUtils.createMockExtensionContext();
    
    mockFs = TestUtils.createMockFileSystem({
      '/fake/path/prompts/roles/test-role.md': '# Test Role\n\n## 角色描述\n\nTest description',
      '/fake/path/prompts/workflows.json': JSON.stringify({
        workflows: [
          {
            id: 'test-workflow',
            name: 'Test Workflow',
            description: 'A test workflow',
            steps: [
              {
                id: 'step1',
                name: 'Step 1',
                role: 'test-role',
                description: 'First step'
              }
            ]
          }
        ]
      })
    });
    
    promptService = new PromptService(mockContext.extensionPath, mockFs);
    workflowService = new WorkflowService(mockContext.extensionPath, mockFs);
  });
  
  test('工作流和角色应该能正确关联', () => {
    const workflow = workflowService.getWorkflowById('test-workflow');
    expect(workflow).toBeDefined();
    
    if (workflow) {
      const step = workflow.steps[0];
      const roles = promptService.getRoles();
      
      // 验证工作流引用的角色确实存在
      const role = roles.find(r => r.id === step.role);
      expect(role).toBeDefined();
      expect(role?.name).toBe('Test Role');
    }
  });
  
  // 更多集成测试用例...
});
```

### 5.2 UI 和服务集成测试

```typescript
// src/tests/integration/ui-services-integration.test.ts
import * as vscode from 'vscode';
import { PromptService } from '../../services/prompt-service';
import { WorkflowService } from '../../services/workflow-service';
import { DevFlowGuideProvider } from '../../ui/webview/dev-flow-guide-provider';
import { FlowStateManager } from '../../ui/webview/flow-state-manager';
import { TestUtils } from '../utils/test-utils';

describe('UI-Service Integration', () => {
  let promptService: PromptService;
  let workflowService: WorkflowService;
  let stateManager: FlowStateManager;
  let provider: DevFlowGuideProvider;
  let mockContext: vscode.ExtensionContext;
  let mockWebviewView: any;
  let mockFs: any;
  
  // 设置测试环境...类似于上面的集成测试
  
  test('完整工作流生命周期', async () => {
    // 初始化流程引导器
    provider.resolveWebviewView(mockWebviewView as any);
    
    // 启动工作流
    const messageHandler = mockWebviewView.webview.onDidReceiveMessage.mock.calls[0][0];
    await messageHandler({ command: 'startFlow', flowId: 'test-workflow' });
    
    // 验证状态更新
    expect(stateManager.state.flowId).toBe('test-workflow');
    expect(stateManager.state.currentStepIndex).toBe(0);
    
    // 验证 WebView 收到更新
    expect(mockWebviewView.webview.postMessage).toHaveBeenCalledWith(
      expect.objectContaining({ command: 'updateState' })
    );
    
    // 更多验证...
  });
  
  // 更多集成测试用例...
});
```

## 六、端到端测试实现计划

使用 VS Code 扩展测试框架实现完整的端到端测试：

```typescript
// src/tests/e2e/extension.test.ts
import * as vscode from 'vscode';
import * as path from 'path';
import { activate, getExtension } from '../../extension';

describe('扩展端到端测试', () => {
  let extension: vscode.Extension<any>;
  
  beforeAll(async () => {
    // 获取扩展实例
    extension = await getExtension();
    // 激活扩展
    await extension.activate();
  });
  
  test('扩展应该正确激活', () => {
    expect(extension.isActive).toBe(true);
  });
  
  test('命令应该正确注册', async () => {
    const commands = await vscode.commands.getCommands();
    expect(commands).toContain('prompt-helper.insertPrompt');
    expect(commands).toContain('prompt-helper.projectWorkflow');
    expect(commands).toContain('prompt-helper.openDevFlowGuide');
  });
  
  // 更多端到端测试用例...
});
```

## 七、性能测试实现计划

```typescript
// src/tests/performance/webview-performance.test.ts
import * as vscode from 'vscode';
import { DevFlowGuideProvider } from '../../ui/webview/dev-flow-guide-provider';
import { TestUtils } from '../utils/test-utils';

describe('WebView 性能测试', () => {
  let provider: DevFlowGuideProvider;
  let mockContext: vscode.ExtensionContext;
  let mockWebviewView: any;
  
  // 设置测试环境...
  
  test('HTML生成性能应该在可接受范围内', () => {
    const start = performance.now();
    
    // 执行HTML生成操作
    provider.resolveWebviewView(mockWebviewView as any);
    
    const end = performance.now();
    const duration = end - start;
    
    // 验证性能指标
    expect(duration).toBeLessThan(100); // 期望HTML生成时间小于100ms
  });
  
  // 更多性能测试用例...
});
```

## 八、测试覆盖率监控与报告

### 8.1 覆盖率报告生成

在 CI/CD 流程中集成覆盖率报告生成：

```yaml
# .github/workflows/test.yml
name: Tests
on: [push, pull_request]
jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '16'
      - name: Install dependencies
        run: npm ci
      - name: Run tests with coverage
        run: npm run test:coverage
      - name: Upload coverage report
        uses: codecov/codecov-action@v2
```

### 8.2 覆盖率可视化

使用 Jest 生成的 HTML 报告或 Codecov 等服务：

```typescript
// 在 package.json 中添加
"scripts": {
  "test:coverage:html": "jest --coverage --coverageReporters=html"
}
```

### 8.3 覆盖率阈值设置

在 Jest 配置中设置覆盖率阈值：

```javascript
// jest.config.js
module.exports = {
  // 其他配置...
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 80,
      lines: 80,
      statements: 80
    },
    './src/services/': {
      branches: 90,
      functions: 90,
      lines: 90,
      statements: 90
    },
    './src/ui/webview/': {
      branches: 80,
      functions: 85,
      lines: 85,
      statements: 85
    }
  }
};
```

## 九、测试体系实施计划

### 9.1 实施阶段划分

1. **第一阶段：测试基础设施建设（2人日）**
   - 配置 Jest
   - 创建测试工具类
   - 实现主要服务的 Mock 对象

2. **第二阶段：核心服务单元测试（2人日）**
   - PromptService 测试
   - WorkflowService 测试
   - 其他核心服务测试

3. **第三阶段：UI 组件测试（2人日）**
   - FlowStateManager 测试
   - DevFlowGuideProvider 测试
   - 其他 UI 组件测试

4. **第四阶段：集成和端到端测试（2人日）**
   - 服务层集成测试
   - UI 和服务集成测试
   - 端到端测试实现

### 9.2 里程碑和交付物

| 里程碑 | 完成时间 | 交付物 |
|-------|---------|--------|
| 测试基础设施建设 | 第2天 | Jest配置、测试工具类、Mock对象 |
| 服务层单元测试 | 第4天 | 服务层测试套件、覆盖率报告 |
| UI组件测试 | 第6天 | UI组件测试套件、覆盖率报告 |
| 集成和端到端测试 | 第8天 | 集成测试套件、端到端测试、覆盖率报告 |

### 9.3 资源需求

- 1-2名测试工程师
- 1名开发工程师（提供技术支持）
- CI 环境

## 十、最佳实践指南

### 10.1 编写测试的最佳实践

1. **遵循 AAA 模式**：Arrange-Act-Assert
2. **一个测试只测试一个方面**
3. **使用描述性的测试名称**
4. **避免测试之间的依赖**
5. **合理使用 setup 和 teardown**
6. **注重测试可读性**

### 10.2 代码设计与可测试性

1. **依赖注入**：使服务和组件便于模拟
2. **接口抽象**：通过接口定义服务边界
3. **避免全局状态**：全局状态难以隔离测试
4. **组件单一职责**：易于理解和测试

### 10.3 测试驱动开发指南

1. **先写测试，再写实现**
2. **小步快跑，频繁测试**
3. **重构后重新运行测试**
4. **测试失败要有明确的错误信息**

## 十一、总结

本测试体系架构完善计划为 Prompt-Helper 项目提供了一个全面的测试策略，涵盖了单元测试、集成测试、端到端测试和性能测试。通过实施这一计划，项目将建立起坚实的测试安全网，为代码重构和后续功能开发提供有力支持。

测试体系的完善不仅能提高代码质量，还能促进更好的架构设计，降低维护成本，提升开发效率。在遵循测试驱动开发的实践中，团队将能更加自信地进行重构和优化，实现更高质量的软件交付。 