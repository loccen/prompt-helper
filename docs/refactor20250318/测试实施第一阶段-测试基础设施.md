# Prompt-Helper 测试实施第一阶段：测试基础设施建设

## 一、概述

测试基础设施是整个测试体系的基石，是后续所有测试工作开展的前提。本文档详细描述测试基础设施建设的具体实施计划，包括测试框架选型与配置、测试工具类实现、Mock对象开发等工作。

## 二、工作目标

1. 搭建基于 Jest 的测试环境
2. 实现通用测试工具类
3. 创建核心服务的 Mock 对象
4. 建立统一的测试模式和约定

## 三、具体任务

### 3.1 测试框架安装与配置

#### 3.1.1 安装依赖

```bash
# 安装 Jest 及其相关依赖
npm install --save-dev jest ts-jest @types/jest

# 安装 Sinon.js 用于增强模拟能力
npm install --save-dev sinon

# 安装 VS Code 扩展测试框架
npm install --save-dev @vscode/test-electron
```

#### 3.1.2 创建 Jest 配置文件

在项目根目录创建 `jest.config.js` 文件：

```javascript
module.exports = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.test.ts'],
  collectCoverage: true,
  collectCoverageFrom: [
    'src/**/*.ts',
    '!src/test/**',
    '!**/node_modules/**'
  ],
  coverageReporters: ['text', 'lcov', 'html'],
  coverageThreshold: {
    global: {
      branches: 70,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['./src/tests/setup.ts'],
  moduleNameMapper: {
    '^vscode$': '<rootDir>/src/tests/mocks/vscode.ts'
  }
};
```

#### 3.1.3 更新 package.json

添加测试相关脚本：

```json
"scripts": {
  "vscode:prepublish": "npm run compile",
  "compile": "tsc -p ./",
  "watch": "tsc -watch -p ./",
  "pretest": "npm run compile",
  "test": "jest",
  "test:watch": "jest --watch",
  "test:coverage": "jest --coverage",
  "test:unit": "jest --testPathPattern=unit",
  "test:integration": "jest --testPathPattern=integration",
  "test:e2e": "jest --testPathPattern=e2e"
}
```

#### 3.1.4 创建测试环境设置文件

创建 `src/tests/setup.ts` 文件：

```typescript
// 全局测试设置
import * as path from 'path';
import * as vscode from 'vscode';

// 模拟 VS Code API
jest.mock('vscode', () => {
  return {
    window: {
      showErrorMessage: jest.fn(),
      showInformationMessage: jest.fn(),
      createWebviewPanel: jest.fn()
    },
    commands: {
      registerCommand: jest.fn(),
      executeCommand: jest.fn()
    },
    Uri: {
      parse: jest.fn().mockImplementation(uri => ({ toString: () => uri })),
      file: jest.fn().mockImplementation(path => ({ path, fsPath: path }))
    },
    EventEmitter: jest.fn().mockImplementation(() => ({
      event: jest.fn(),
      fire: jest.fn()
    }))
  };
});

// 全局测试前置设置
global.beforeEach(() => {
  jest.clearAllMocks();
});
```

### 3.2 测试工具类实现

创建 `src/tests/utils/test-utils.ts` 文件：

```typescript
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';

/**
 * 测试工具类，提供测试所需的各种辅助功能
 */
export class TestUtils {
  /**
   * 创建模拟的扩展上下文
   */
  public static createMockExtensionContext(): vscode.ExtensionContext {
    const mockStorage = new Map<string, any>();
    
    return {
      subscriptions: [],
      extensionPath: '/fake/path',
      extensionUri: vscode.Uri.parse('file:///fake/path'),
      storagePath: '/fake/storage',
      globalStoragePath: '/fake/global-storage',
      logPath: '/fake/log',
      workspaceState: {
        get: jest.fn((key: string) => mockStorage.get(key)),
        update: jest.fn((key: string, value: any) => {
          mockStorage.set(key, value);
          return Promise.resolve();
        })
      } as any,
      globalState: {
        get: jest.fn((key: string) => mockStorage.get(key)),
        update: jest.fn((key: string, value: any) => {
          mockStorage.set(key, value);
          return Promise.resolve();
        }),
        setKeysForSync: jest.fn()
      } as any,
      asAbsolutePath: jest.fn(relativePath => path.join('/fake/path', relativePath))
    } as any;
  }
  
  /**
   * 创建模拟的文件系统
   * @param files 要模拟的文件内容映射
   */
  public static createMockFileSystem(files: Record<string, string>): any {
    return {
      existsSync: jest.fn(filePath => !!files[filePath]),
      readdirSync: jest.fn(dirPath => {
        const dirPrefix = dirPath.endsWith('/') ? dirPath : `${dirPath}/`;
        return Object.keys(files)
          .filter(filePath => filePath.startsWith(dirPrefix))
          .map(filePath => path.basename(filePath));
      }),
      readFileSync: jest.fn(filePath => {
        if (!files[filePath]) {
          throw new Error(`File not found: ${filePath}`);
        }
        return files[filePath];
      }),
      statSync: jest.fn(filePath => ({
        isDirectory: () => !filePath.includes('.')
      }))
    };
  }
  
  /**
   * 创建模拟的 WebView
   */
  public static createMockWebview(): any {
    return {
      onDidReceiveMessage: jest.fn(callback => {
        // 保存回调函数，以便在测试中模拟消息
        (TestUtils as any).lastMessageCallback = callback;
        return { dispose: jest.fn() };
      }),
      postMessage: jest.fn().mockResolvedValue(true),
      html: '',
      options: {},
      cspSource: 'https://fake-source',
      asWebviewUri: jest.fn(uri => uri)
    };
  }
  
  /**
   * 创建模拟的 WebViewView
   */
  public static createMockWebviewView(webview?: any): any {
    return {
      webview: webview || TestUtils.createMockWebview(),
      visible: true,
      onDidChangeVisibility: jest.fn(callback => ({ dispose: jest.fn() })),
      onDidDispose: jest.fn(callback => ({ dispose: jest.fn() }))
    };
  }
  
  /**
   * 模拟 WebView 发送消息
   * @param message 要发送的消息
   */
  public static simulateWebviewMessage(message: any): Promise<any> {
    if (!(TestUtils as any).lastMessageCallback) {
      throw new Error('No message handler registered');
    }
    return Promise.resolve((TestUtils as any).lastMessageCallback(message));
  }
  
  /**
   * 等待指定的毫秒数
   * @param ms 等待的毫秒数
   */
  public static wait(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  
  /**
   * 创建临时测试文件
   * @param content 文件内容
   * @param extension 文件扩展名
   */
  public static createTempFile(content: string, extension: string = '.txt'): string {
    const tempDir = path.join(__dirname, '../../../temp');
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    
    const filePath = path.join(tempDir, `test-${Date.now()}${extension}`);
    fs.writeFileSync(filePath, content);
    return filePath;
  }
  
  /**
   * 清理临时测试文件
   * @param filePath 文件路径
   */
  public static cleanupTempFile(filePath: string): void {
    if (fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
    }
  }
}
```

### 3.3 创建 VS Code API 模拟

创建 `src/tests/mocks/vscode.ts` 文件：

```typescript
/**
 * VS Code API 模拟
 * 用于在测试环境中模拟 VS Code 的 API
 */

export class Uri {
  public readonly scheme: string;
  public readonly path: string;
  public readonly fsPath: string;
  
  constructor(scheme: string, path: string) {
    this.scheme = scheme;
    this.path = path;
    this.fsPath = path;
  }
  
  public with(change: { scheme?: string; path?: string }): Uri {
    return new Uri(
      change.scheme || this.scheme,
      change.path || this.path
    );
  }
  
  public toString(): string {
    return `${this.scheme}://${this.path}`;
  }
  
  public static file(path: string): Uri {
    return new Uri('file', path);
  }
  
  public static parse(uri: string): Uri {
    const match = uri.match(/^([a-z]+):\/\/(.+)$/);
    if (match) {
      return new Uri(match[1], match[2]);
    }
    return new Uri('file', uri);
  }
}

export class Disposable {
  public static from(...disposables: { dispose(): any }[]): Disposable {
    return new Disposable(() => {
      for (const disposable of disposables) {
        disposable.dispose();
      }
    });
  }
  
  constructor(private readonly callOnDispose: Function) {}
  
  public dispose(): any {
    this.callOnDispose();
  }
}

export class EventEmitter<T> {
  private readonly listeners: ((e: T) => any)[] = [];
  
  public event(listener: (e: T) => any): Disposable {
    this.listeners.push(listener);
    return new Disposable(() => {
      const index = this.listeners.indexOf(listener);
      if (index >= 0) {
        this.listeners.splice(index, 1);
      }
    });
  }
  
  public fire(event: T): void {
    for (const listener of this.listeners) {
      listener(event);
    }
  }
}

export const window = {
  showInformationMessage: jest.fn(),
  showErrorMessage: jest.fn(),
  showWarningMessage: jest.fn(),
  createOutputChannel: jest.fn().mockReturnValue({
    appendLine: jest.fn(),
    append: jest.fn(),
    show: jest.fn(),
    dispose: jest.fn()
  }),
  createWebviewPanel: jest.fn().mockReturnValue({
    webview: {
      onDidReceiveMessage: jest.fn(),
      postMessage: jest.fn().mockResolvedValue(true),
      html: '',
      options: {}
    },
    onDidDispose: jest.fn(),
    onDidChangeViewState: jest.fn(),
    reveal: jest.fn(),
    dispose: jest.fn()
  }),
  registerWebviewViewProvider: jest.fn()
};

export const commands = {
  registerCommand: jest.fn().mockReturnValue(new Disposable(() => {})),
  executeCommand: jest.fn()
};

export const workspace = {
  getConfiguration: jest.fn().mockReturnValue({
    get: jest.fn(),
    update: jest.fn().mockResolvedValue(undefined),
    has: jest.fn()
  }),
  workspaceFolders: [],
  onDidChangeConfiguration: jest.fn().mockReturnValue(new Disposable(() => {}))
};

export const ExtensionContext = jest.fn().mockImplementation(() => {
  const storage = new Map<string, any>();
  return {
    subscriptions: [],
    extensionPath: '/fake/path',
    extensionUri: Uri.parse('file:///fake/path'),
    globalState: {
      get: jest.fn(key => storage.get(key)),
      update: jest.fn((key, value) => {
        storage.set(key, value);
        return Promise.resolve();
      }),
      setKeysForSync: jest.fn()
    },
    workspaceState: {
      get: jest.fn(key => storage.get(key)),
      update: jest.fn((key, value) => {
        storage.set(key, value);
        return Promise.resolve();
      })
    },
    asAbsolutePath: jest.fn(path => `/fake/path/${path}`)
  };
});

export enum ViewColumn {
  Active = -1,
  Beside = -2,
  One = 1,
  Two = 2,
  Three = 3
}

export class CancellationTokenSource {
  public readonly token = { isCancellationRequested: false };
  
  public cancel(): void {
    (this.token as any).isCancellationRequested = true;
  }
  
  public dispose(): void {}
}

export const extensions = {
  getExtension: jest.fn()
};

// 导出模拟的 VS Code API
export default {
  Uri,
  Disposable,
  EventEmitter,
  window,
  commands,
  workspace,
  ExtensionContext,
  ViewColumn,
  CancellationTokenSource,
  extensions
};
```

### 3.4 核心服务 Mock 对象实现

#### 3.4.1 PromptService Mock

创建 `src/tests/mocks/mock-prompt-service.ts` 文件：

```typescript
import { IPromptRole } from '../../interfaces';

/**
 * PromptService的模拟实现
 */
export class MockPromptService {
  private roles: IPromptRole[] = [];
  
  /**
   * 创建 PromptService 的模拟实例
   * @param mockRoles 预设的角色列表
   */
  constructor(mockRoles: IPromptRole[] = []) {
    this.roles = mockRoles;
  }
  
  /**
   * 获取所有角色
   */
  public getRoles(): IPromptRole[] {
    return this.roles;
  }
  
  /**
   * 根据ID获取角色
   * @param roleId 角色ID
   */
  public getRoleById(roleId: string): IPromptRole | undefined {
    return this.roles.find(r => r.id === roleId);
  }
  
  /**
   * 获取角色提示词内容
   * @param roleId 角色ID
   */
  public async getPromptContent(roleId: string): Promise<string> {
    const role = this.getRoleById(roleId);
    if (!role) {
      throw new Error(`Role not found: ${roleId}`);
    }
    return `# ${role.name}\n\n## 角色描述\n\n${role.description}\n\n## Mock content for ${role.name}`;
  }
  
  /**
   * 注册一个新角色
   * @param role 要添加的角色
   */
  public addRole(role: IPromptRole): void {
    this.roles.push(role);
  }
  
  /**
   * 清空所有角色
   */
  public clearRoles(): void {
    this.roles = [];
  }
}
```

#### 3.4.2 WorkflowService Mock

创建 `src/tests/mocks/mock-workflow-service.ts` 文件：

```typescript
import { IWorkflow, IWorkflowStep } from '../../interfaces';

/**
 * WorkflowService的模拟实现
 */
export class MockWorkflowService {
  private workflows: IWorkflow[] = [];
  
  /**
   * 创建 WorkflowService 的模拟实例
   * @param mockWorkflows 预设的工作流列表
   */
  constructor(mockWorkflows: IWorkflow[] = []) {
    this.workflows = mockWorkflows;
  }
  
  /**
   * 获取所有工作流
   */
  public getWorkflows(): IWorkflow[] {
    return this.workflows;
  }
  
  /**
   * 根据ID获取工作流
   * @param workflowId 工作流ID
   */
  public getWorkflowById(workflowId: string): IWorkflow | undefined {
    return this.workflows.find(w => w.id === workflowId);
  }
  
  /**
   * 创建一个mock工作流
   * @param id 工作流ID
   * @param name 工作流名称
   * @param steps 工作流步骤
   */
  public createMockWorkflow(id: string, name: string, steps: IWorkflowStep[]): IWorkflow {
    const workflow: IWorkflow = {
      id,
      name,
      description: `Mock workflow: ${name}`,
      steps
    };
    
    this.workflows.push(workflow);
    return workflow;
  }
  
  /**
   * 添加工作流
   * @param workflow 要添加的工作流
   */
  public addWorkflow(workflow: IWorkflow): void {
    this.workflows.push(workflow);
  }
  
  /**
   * 清空所有工作流
   */
  public clearWorkflows(): void {
    this.workflows = [];
  }
}
```

#### 3.4.3 FlowStateManager Mock

创建 `src/tests/mocks/mock-flow-state-manager.ts` 文件：

```typescript
import { IFlowState } from '../../interfaces';

/**
 * FlowStateManager的模拟实现
 */
export class MockFlowStateManager {
  private _state: IFlowState = {
    flowId: '',
    currentStepIndex: 0,
    completedSteps: [],
    projectContext: {}
  };
  
  /**
   * 获取当前状态
   */
  public get state(): IFlowState {
    return this._state;
  }
  
  /**
   * 重置状态
   */
  public resetState(): void {
    this._state = {
      flowId: '',
      currentStepIndex: 0,
      completedSteps: [],
      projectContext: {}
    };
  }
  
  /**
   * 更新状态
   * @param newState 新状态
   */
  public updateState(newState: Partial<IFlowState>): void {
    this._state = {
      ...this._state,
      ...newState
    };
  }
  
  /**
   * 设置流程ID
   * @param flowId 流程ID
   */
  public setFlowId(flowId: string): void {
    this._state.flowId = flowId;
  }
  
  /**
   * 设置当前步骤索引
   * @param index 步骤索引
   */
  public setCurrentStepIndex(index: number): void {
    this._state.currentStepIndex = index;
  }
  
  /**
   * 添加已完成步骤
   * @param stepId 步骤ID
   */
  public addCompletedStep(stepId: string): void {
    if (!this._state.completedSteps.includes(stepId)) {
      this._state.completedSteps.push(stepId);
    }
  }
  
  /**
   * 更新项目上下文
   * @param context 上下文数据
   */
  public updateProjectContext(context: Record<string, any>): void {
    this._state.projectContext = {
      ...this._state.projectContext,
      ...context
    };
  }
  
  /**
   * 初始化新流程
   * @param flowId 流程ID
   */
  public initNewFlow(flowId: string): void {
    this._state = {
      flowId,
      currentStepIndex: 0,
      completedSteps: [],
      projectContext: {}
    };
  }
  
  /**
   * 移动到下一步
   */
  public moveToNextStep(): void {
    this._state.currentStepIndex++;
  }
  
  /**
   * 移动到上一步
   */
  public moveToPrevStep(): void {
    if (this._state.currentStepIndex > 0) {
      this._state.currentStepIndex--;
    }
  }
  
  /**
   * 检查步骤是否已完成
   * @param stepId 步骤ID
   */
  public isStepCompleted(stepId: string): boolean {
    return this._state.completedSteps.includes(stepId);
  }
}
```

## 四、测试目录结构建立

创建所需的测试目录结构：

```bash
mkdir -p src/tests/utils
mkdir -p src/tests/mocks
mkdir -p src/tests/unit/services
mkdir -p src/tests/unit/ui/tree-view
mkdir -p src/tests/unit/ui/webview
mkdir -p src/tests/integration
mkdir -p src/tests/e2e
mkdir -p src/tests/performance
```

## 五、测试约定与规范

### 5.1 命名规范

- 测试文件：`[被测文件名].test.ts`
- 测试描述：应清晰描述被测功能和预期行为
- 测试工具类：应用 `TestUtils` 前缀
- Mock 对象：应用 `Mock` 前缀

### 5.2 测试编写规范

1. **每个测试应该独立**：一个测试不应依赖于其他测试的结果
2. **每个测试只测试一个方面**：一个测试应该专注于一个功能点
3. **遵循 AAA 模式**：Arrange-Act-Assert（准备-执行-断言）
4. **命名应该具有描述性**：测试名称应描述"被测系统在什么条件下应该做什么"

示例：

```typescript
// 命名规范
test('should return correct role when valid ID is provided', () => {
  // Arrange
  const mockRole = { id: 'test-role', name: 'Test Role' };
  const service = new MockPromptService([mockRole]);
  
  // Act
  const result = service.getRoleById('test-role');
  
  // Assert
  expect(result).toEqual(mockRole);
});
```

### 5.3 测试覆盖率要求

- 单元测试：每个服务/组件的关键方法应有测试覆盖
- 边界条件：应测试正常情况和异常情况
- 异步处理：应正确测试 Promise 的 resolve 和 reject 情况

## 六、交付物

完成本阶段后，将交付以下成果：

1. Jest 配置和环境设置
2. 完整的测试工具类和 Mock 对象
3. 统一的测试规范文档
4. 测试目录结构

## 七、后续工作

完成测试基础设施建设后，将进入第二阶段：核心服务单元测试实现，为所有核心服务编写全面的单元测试，建立首批测试用例作为模板，指导后续测试工作。 