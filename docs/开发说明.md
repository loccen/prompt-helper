# Prompt-Helper  开发说明

## 项目概述

Prompt-Helper 是一款为Cursor编辑器开发的VSCode插件，旨在帮助开发者通过预置角色提示词快速完成项目开发流程。插件提供了多种开发角色的提示词和预定义的开发流程，用户只需提供一个项目想法，便可通过不同角色分工，一步步完成完整的项目开发。

## 技术架构

插件基于VSCode扩展API开发，主要使用TypeScript语言。核心组件包括：

1. **角色提示词提供者**：负责加载和管理预置的角色提示词
2. **工作流提供者**：负责加载和管理预定义的开发流程
3. **UI组件**：包括侧边栏视图、树视图等
4. **命令处理**：处理插入提示词、启动工作流等命令

## 目录结构

```
prompt-helper/
├── src/                      # 源代码目录
│   ├── extension.ts          # 插件入口文件
│   ├── promptProvider.ts     # 角色提示词提供者
│   ├── workflowProvider.ts   # 工作流提供者
│   └── utils.ts              # 实用工具函数
├── prompts/                  # 提示词和工作流定义
│   ├── roles/                # 角色提示词目录
│   │   ├── product-manager.md    # 产品经理角色提示词
│   │   ├── architect.md          # 系统架构师角色提示词
│   │   ├── developer.md          # 开发工程师角色提示词
│   │   └── vscodeplugin-developer.md  # VSCode插件开发工程师角色提示词
│   └── workflows.json        # 工作流定义文件
├── resources/                # 资源文件目录
│   └── icon.svg              # 插件图标
├── docs/                     # 文档目录
│   ├── 使用指南.md            # 用户使用指南
│   ├── 开发说明.md            # 开发说明文档
│   └── images/               # 图片和演示文件
│       └── workflow-demo.html    # 工作流程演示图表
├── package.json              # 插件配置文件
└── tsconfig.json             # TypeScript配置文件
```

## 核心功能实现

### 1. 角色提示词管理

角色提示词以Markdown文件形式存储在`prompts/roles`目录下，通过`PromptProvider`类加载和管理。每个角色提示词文件包含角色描述、技能专长、工作方法等信息。

```typescript
// 加载角色提示词
private loadRoles() {
  try {
    this.roles = [];
    if (fs.existsSync(this.rolesDir)) {
      const files = fs.readdirSync(this.rolesDir).filter(file => file.endsWith('.md'));
      
      for (const file of files) {
        const filePath = path.join(this.rolesDir, file);
        const content = fs.readFileSync(filePath, 'utf-8');
        const titleMatch = content.match(/^# (.+)/m);
        const descriptionMatch = content.match(/## 角色描述\s*\n\s*(.+)/m);
        
        if (titleMatch) {
          const id = path.basename(file, '.md');
          const name = titleMatch[1].replace('角色提示词', '').trim();
          const description = descriptionMatch ? descriptionMatch[1].trim() : '';
          
          this.roles.push({
            id,
            name,
            description,
            filePath
          });
        }
      }
    }
  } catch (error) {
    console.error('加载角色提示词失败:', error);
  }
}
```

### 2. 工作流管理

工作流定义存储在`prompts/workflows.json`文件中，通过`WorkflowProvider`类加载和管理。每个工作流包含多个步骤，每个步骤关联一个角色和提示词模板。

```typescript
// 启动工作流
async startWorkflow(workflowId: string, params: Record<string, string>): Promise<void> {
  const workflow = this.workflows.find(wf => wf.id === workflowId);
  if (!workflow) {
    throw new Error(`找不到工作流: ${workflowId}`);
  }

  // 获取第一个步骤
  const firstStep = workflow.steps[0];
  if (!firstStep) {
    throw new Error(`工作流没有定义步骤: ${workflowId}`);
  }

  // 格式化提示词，替换变量
  let promptContent = firstStep.prompt;
  for (const [key, value] of Object.entries(params)) {
    promptContent = promptContent.replace(new RegExp(`{{${key}}}`, 'g'), value);
  }

  // 插入到聊天窗口
  await insertPromptToChat(promptContent);
}
```

### 3. 目录形式的输出件管理

为支持多文件输出，插件实现了目录输出机制，将每个步骤的输出与对应目录关联起来，并在后续步骤中引用：

```typescript
// 在标记步骤完成时收集目录信息
private async _completeCurrentStep(output: Record<string, any> = {}): Promise<void> {
  // ...
  const outputDirPath = await vscode.window.showInputBox({
    prompt: `请输入此步骤的输出件目录路径（相对于项目根目录）`,
    placeHolder: '例如: docs/产品经理, src/designs 等',
    ignoreFocusOut: true // 防止用户切换窗口时对话框关闭
  });
  
  if (outputDirPath !== undefined) {
    const roleName = this._getRoleNameFromId(currentStep.role);
    
    // 保存目录路径映射
    const existingRoleDirPaths = (this._flowState.projectContext['roleDirPaths'] as Record<string, string>) || {};
    output['roleDirPaths'] = {
      ...existingRoleDirPaths,
      [roleName]: outputDirPath
    };
  }
  // ...
}

// 在应用角色提示词时引用目录信息
private async _applyRolePrompt(roleId: string): Promise<void> {
  // ...
  // 处理前一步骤的输出目录信息
  const roleDirPaths = this._flowState.projectContext['roleDirPaths'] as Record<string, string>;
  if (roleDirPaths && typeof roleDirPaths === 'object') {
    const prevRoleName = this._getRoleNameFromId(prevStep.role);
    const prevRoleDirPath = roleDirPaths[prevRoleName];
    
    if (prevRoleDirPath) {
      contextInfo += `\n\n目录'${prevRoleDirPath}'下的文件为${prevRoleName}给出的输出件，请你作为${currentRoleName}，仔细阅读相关文档，根据这些内容继续你的工作。\n`;
    }
  }
  // ...
}
```

### 4. 状态持久化和多项目支持

插件使用VSCode的workspaceState API实现工作流状态持久化和多项目支持：

```typescript
// 状态持久化
private _persistFlowState(): void {
  try {
    // 获取当前工作区的存储键
    const storageKey = this._getStorageKey();
    
    // 将状态保存到工作区状态存储
    this._context.workspaceState.update(storageKey, this._flowState);
    
    console.log(`已保存流程状态到: ${storageKey}`);
  } catch (error) {
    console.error('保存流程状态失败:', error);
  }
}

// 工作区识别
private _getStorageKey(): string {
  let workspaceId = 'default';
  
  // 获取当前工作区文件夹路径作为唯一ID
  if (vscode.workspace.workspaceFolders && vscode.workspace.workspaceFolders.length > 0) {
    workspaceId = vscode.workspace.workspaceFolders[0].uri.fsPath;
    
    // 对路径进行简单处理避免特殊字符
    workspaceId = workspaceId.replace(/[^a-zA-Z0-9]/g, '_');
  }
  
  return `${this.STORAGE_KEY_PREFIX}.${workspaceId}`;
}

// 状态恢复
private _restoreFlowState(): void {
  try {
    const storageKey = this._getStorageKey();
    const savedState = this._context.workspaceState.get<IFlowState>(storageKey);
    
    if (savedState) {
      console.log(`已恢复流程状态从: ${storageKey}`);
      this._flowState = savedState;
    }
  } catch (error) {
    console.error('恢复流程状态失败:', error);
  }
}
```

## 扩展和自定义

### 添加新角色提示词

1. 在`prompts/roles`目录下创建新的Markdown文件
2. 按照现有角色提示词的格式编写内容
3. 重启插件或刷新视图，新角色将自动加载

### 添加新工作流

1. 编辑`prompts/workflows.json`文件
2. 按照现有工作流的格式添加新的工作流定义
3. 重启插件或刷新视图，新工作流将自动加载

## 构建和发布

### 构建插件

```bash
npm run compile
```

### 打包插件

```bash
npm run vscode:prepublish
```

### 发布到VSCode扩展市场

1. 获取发布者账号和Personal Access Token
2. 使用vsce工具打包和发布插件

```bash
npm install -g vsce
vsce package
vsce publish
```

## 注意事项

1. 插件依赖Cursor编辑器的特定命令和行为，如果Cursor更新可能需要调整相应代码
2. 插入提示词功能使用剪贴板API，可能会临时覆盖用户的剪贴板内容
3. 角色提示词文件需要遵循特定格式，以确保正确解析标题和描述 

## 一、重构后的代码架构

Prompt-Helper 插件经过重构，采用了更加清晰的分层架构和组件化设计。新架构将有助于提高代码的可维护性、可测试性和可扩展性。

### 1. 核心架构图

```
┌─────────────────────────────────────────────────────────────┐
│                      VSCode Extension API                    │
└───────────────────────────────┬─────────────────────────────┘
                                │
┌───────────────────────────────▼─────────────────────────────┐
│                        extension.ts                          │
│                    (插件入口和注册中心)                        │
└─────┬───────────────────┬───────────────────────┬───────────┘
      │                   │                       │
┌─────▼────────┐   ┌─────▼────────┐      ┌───────▼────────────┐
│  Services    │   │     UI       │      │      Utils         │
│  (服务层)    │   │   (界面层)   │      │     (工具层)       │
└─────┬────────┘   └─────┬────────┘      └────────────────────┘
      │                  │                        
┌─────▼────────┐   ┌─────▼────────────────────────┐      
│   Config     │   │       Interfaces             │      
│  (配置层)    │   │      (接口定义层)           │      
└──────────────┘   └──────────────────────────────┘      
```

### 2. 文件结构

```
src/
├── config/               # 配置相关模块
│   ├── categories.ts     # 角色分类配置
│   └── index.ts          # 配置模块入口
├── interfaces.ts         # 共用接口定义
├── services/             # 服务层，负责数据访问和处理
│   ├── prompt-service.ts # 提示词服务
│   ├── workflow-service.ts # 工作流服务
│   └── index.ts          # 服务模块入口
├── ui/                   # UI层，负责界面展示
│   ├── tree-view/        # 树视图组件
│   │   ├── prompt-tree-provider.ts  # 提示词树视图提供者
│   │   ├── workflow-tree-provider.ts # 工作流树视图提供者
│   │   └── index.ts      # 树视图模块入口
│   ├── webview/          # WebView组件
│   │   ├── dev-flow-guide-provider.ts # 开发流程引导器
│   │   ├── dev-flow-html-generator.ts # HTML生成器
│   │   ├── flow-state-manager.ts     # 流程状态管理器
│   │   ├── flow-steps-mapping-service.ts # 步骤映射服务
│   │   └── index.ts      # WebView模块入口
│   └── index.ts          # UI模块入口
├── tests/                # 测试模块
├── utils.ts              # 共用工具函数
└── extension.ts          # 插件入口点
```

## 二、组件详解

### 1. 服务层 (services/)

服务层负责数据访问和核心业务逻辑，与UI层分离。

#### PromptService

提示词服务负责加载和管理角色提示词数据。

```typescript
export class PromptService {
  // 加载提示词数据
  getRoles(): IPromptRole[];
  
  // 获取分类信息
  getCategories(): string[];
  
  // 根据ID获取角色
  getRoleById(roleId: string): IPromptRole | undefined;
  
  // 根据分类获取角色列表
  getRolesByCategory(category: string): IPromptRole[];
  
  // 获取提示词内容
  getPromptContent(roleId: string): Promise<string | undefined>;
  
  // 重新加载数据
  reload(): void;
}
```

#### WorkflowService

工作流服务负责加载和管理工作流定义。

```typescript
export class WorkflowService {
  // 获取所有工作流
  getWorkflows(): IWorkflow[];
  
  // 根据ID获取工作流
  getWorkflowById(workflowId: string): IWorkflow | undefined;
  
  // 重新加载数据
  reload(): void;
}
```

### 2. UI层 (ui/)

UI层负责用户界面展示和交互，分为树视图和WebView两部分。

#### 树视图 (tree-view/)

##### PromptTreeProvider

提供角色提示词的树视图数据。

```typescript
export class PromptTreeProvider implements vscode.TreeDataProvider<PromptTreeItem> {
  // 刷新树视图
  refresh(): void;
  
  // 获取树项
  getTreeItem(element: PromptTreeItem): vscode.TreeItem;
  
  // 获取子项
  getChildren(element?: PromptTreeItem): Promise<PromptTreeItem[]>;
  
  // 获取提示词内容
  getPromptContent(roleId: string): Promise<string | undefined>;
}
```

##### WorkflowTreeProvider

提供工作流的树视图数据。

```typescript
export class WorkflowTreeProvider implements vscode.TreeDataProvider<WorkflowTreeItem> {
  // 刷新树视图
  refresh(): void;
  
  // 获取树项
  getTreeItem(element: WorkflowTreeItem): vscode.TreeItem;
  
  // 获取子项
  getChildren(element?: WorkflowTreeItem): Promise<WorkflowTreeItem[]>;
  
  // 获取所有工作流
  getWorkflows(): Promise<IWorkflow[]>;
  
  // 启动工作流
  startWorkflow(workflowId: string, params: Record<string, string>): Promise<void>;
}
```

#### WebView (webview/)

##### DevFlowGuideProvider

开发流程引导器的主控制器，协调其他WebView组件工作。

```typescript
export class DevFlowGuideProvider implements vscode.WebviewViewProvider {
  // 创建并初始化WebView视图
  resolveWebviewView(webviewView: vscode.WebviewView): void;
  
  // (私有方法) 显示欢迎页
  private _showWelcomePage(errorMessage?: string): void;
  
  // (私有方法) 启动新流程
  private _startNewFlow(flowId: string): Promise<void>;
  
  // (私有方法) 更新流程视图
  private _updateFlowView(workflow: IWorkflow): Promise<void>;
}
```

##### FlowStateManager

流程状态管理器，负责管理和持久化流程状态。

```typescript
export class FlowStateManager {
  // 获取当前状态
  get state(): IFlowState;
  
  // 设置流程ID
  setFlowId(flowId: string): void;
  
  // 设置当前步骤索引
  setCurrentStepIndex(index: number): void;
  
  // 添加已完成步骤
  addCompletedStep(stepId: string): void;
  
  // 更新项目上下文
  updateProjectContext(context: Record<string, any>): void;
  
  // 重置状态
  resetState(): void;
  
  // 检查步骤是否已完成
  isStepCompleted(stepId: string): boolean;
  
  // 初始化新流程
  initNewFlow(flowId: string): void;
  
  // 移动到下一步
  moveToNextStep(): void;
  
  // 移动到上一步
  moveToPrevStep(): void;
}
```

##### DevFlowHtmlGenerator

HTML生成器，负责生成WebView界面的HTML内容。

```typescript
export class DevFlowHtmlGenerator {
  // 获取欢迎页面HTML
  getWelcomePageHtml(workflows: IWorkflow[], errorMessage?: string): string;
  
  // 获取步骤视图HTML
  getStepViewHtml(workflow: IWorkflow, currentStep: any, ...): Promise<string>;
  
  // 获取角色卡片HTML
  getRoleCardsHtml(roleIds: string[], roleNames: string[]): string;
  
  // 获取流程完成HTML
  getFlowCompletionHtml(workflow: IWorkflow): string;
}
```

##### FlowStepsMappingService

流程步骤映射服务，管理流程步骤与角色的映射关系。

```typescript
export class FlowStepsMappingService {
  // 获取特定工作流的步骤映射
  getFlowStepsMapping(flowId: string): IFlowStep[];
  
  // 获取所有流程步骤映射
  getAllFlowStepsMapping(): Record<string, { steps: IFlowStep[] }>;
  
  // 重新加载映射数据
  reload(): void;
}
```

### 3. 工具层 (utils.ts)

提供通用工具函数，如日志记录、错误处理和提示词插入。

```typescript
// 日志记录
export function log(message: string, showInUI: boolean = false): void;

// 错误处理
export function handleError(error: any, message: string, showToUser: boolean = true): void;

// 将提示词插入到聊天窗口
export function insertPromptToChat(content: string): Promise<void>;

// 从角色ID提取角色名称
export function extractRoleNameFromId(roleId: string): string;
```

### 4. 配置层 (config/)

管理全局配置信息，如角色分类映射。

```typescript
// 角色分类映射
export const categoryMapping: ICategoryMapping;

// 根据文件名获取分类
export function getCategoryFromFileName(fileName: string): string;
```

### 5. 接口层 (interfaces.ts)

定义各组件间通信的接口和类型。

```typescript
// 角色提示词接口
export interface IPromptRole { ... }

// 工作流步骤接口
export interface IWorkflowStep { ... }

// 工作流接口
export interface IWorkflow { ... }

// 流程步骤接口
export interface IFlowStep { ... }

// 流程状态接口
export interface IFlowState { ... }

// 树节点基类
export class BaseTreeItem extends vscode.TreeItem { ... }
```

## 三、代码贡献指南

### 1. 环境设置

```bash
# 克隆仓库
git clone https://github.com/yourusername/prompt-helper.git
cd prompt-helper

# 安装依赖
npm install

# 打开VSCode
code .
```

### 2. 开发流程

1. 创建新分支
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. 编写代码，遵循以下原则：
   - 遵循现有的代码风格和架构
   - 单一职责原则：每个类或函数只做一件事
   - 依赖注入：通过构造函数注入依赖
   - 接口隔离：设计清晰的接口边界

3. 添加测试
   ```bash
   # 编写测试代码
   # 运行测试
   npm test
   ```

4. 提交代码
   ```bash
   git add .
   git commit -m "feat: 添加新功能xxx"
   git push origin feature/your-feature-name
   ```

5. 创建Pull Request

### 3. 代码规范

#### 命名规范

- 文件名：使用连字符分隔，如 `prompt-service.ts`
- 类名：使用PascalCase，如 `PromptService`
- 接口名：以 `I` 开头，使用PascalCase，如 `IPromptRole`
- 变量名和函数名：使用camelCase，如 `getPromptContent`
- 私有成员变量：以 `_` 开头，如 `_flowState`

#### 代码风格

- 使用TypeScript严格模式
- 使用async/await而不是Promise链
- 适当添加注释，特别是公共API
- 每个函数不超过30行，每个文件不超过300行
- 使用强类型，避免使用any

#### 提交规范

使用Angular提交规范：

- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码风格调整
- `refactor`: 重构代码
- `test`: 添加测试
- `chore`: 构建过程或辅助工具变动

### 4. 扩展指南

#### 添加新服务

1. 在 `services/` 目录创建新服务文件
2. 在 `interfaces.ts` 定义服务接口
3. 实现服务类
4. 在 `services/index.ts` 导出新服务
5. 在 `extension.ts` 初始化服务并注入依赖

#### 添加新UI组件

1. 在 `ui/` 下的适当目录创建新组件文件
2. 实现组件类
3. 在相应的 `index.ts` 导出组件
4. 在 `extension.ts` 初始化组件并注册视图

#### 添加新命令

1. 在 `package.json` 的 `contributes.commands` 添加命令定义
2. 在 `extension.ts` 注册命令处理函数
3. 实现命令逻辑

## 四、测试指南

### 1. 单元测试

使用Mocha和assert编写单元测试：

```typescript
import * as assert from 'assert';
import { YourClass } from '../path/to/your-class';

suite('YourClass Tests', () => {
  test('should do something', () => {
    const instance = new YourClass();
    const result = instance.someMethod();
    assert.strictEqual(result, expectedValue);
  });
});
```

### 2. 集成测试

测试组件间的交互：

```typescript
suite('Integration Tests', () => {
  test('components should work together', async () => {
    // 设置测试环境
    const service = new SomeService();
    const component = new SomeComponent(service);
    
    // 执行操作
    await component.doSomething();
    
    // 验证结果
    assert.strictEqual(service.getState(), expectedState);
  });
});
```

### 3. 模拟依赖

使用Mock对象模拟外部依赖：

```typescript
// 创建Mock对象
function createMockService() {
  return {
    getData: () => Promise.resolve('mock data'),
    saveData: (data: string) => Promise.resolve(true)
  };
}

// 在测试中使用
test('should handle data', async () => {
  const mockService = createMockService();
  const component = new SomeComponent(mockService as any);
  
  await component.processData();
  
  // 验证结果
});
```

## 五、调试技巧

### 1. VSCode调试

1. 按 F5 启动插件调试会话
2. 使用断点调试代码
3. 查看调试控制台输出
4. 使用 `log()` 函数记录关键信息

### 2. 常见问题排查

#### 插件未加载

- 检查 `package.json` 中的激活事件
- 查看 VSCode 开发控制台是否有错误

#### 视图未显示

- 确认视图ID在 `package.json` 中正确注册
- 检查 `registerWebviewViewProvider` 的参数

#### 数据加载失败

- 检查文件路径是否正确
- 确认文件格式符合预期

## 六、发布流程

### 1. 版本管理

使用语义化版本：

- 主版本号：不兼容的API变更
- 次版本号：向下兼容的功能新增
- 修订号：向下兼容的问题修复

### 2. 准备发布

1. 更新版本号
   ```bash
   npm version [patch|minor|major]
   ```

2. 更新 `CHANGELOG.md`

3. 运行测试确保质量
   ```bash
   npm test
   ```

4. 打包插件
   ```bash
   npm run package
   ```

### 3. 发布插件

1. 上传到 VSCode Marketplace
   ```bash
   vsce publish
   ```

2. 创建 GitHub Release
   ```bash
   git tag v1.x.x
   git push origin v1.x.x
   ```
   
## 七、性能优化建议

### 1. 数据加载优化

- 使用延迟加载策略，特别是大文件
- 实现缓存机制避免重复加载
- 使用流式处理大型文件

### 2. UI响应优化

- 使用虚拟列表显示大量数据
- 异步操作不阻塞UI线程
- 提供加载指示器改善用户体验

### 3. 内存管理

- 及时释放不再需要的资源
- 避免在循环中创建大量对象
- 使用对象池复用常用对象

## 八、安全最佳实践

### 1. 输入验证

- 验证用户输入和外部数据
- 避免使用 `eval` 和不安全的JSON解析
- 防止路径遍历攻击

### 2. 数据存储

- 敏感数据使用 VSCode 凭证存储
- 避免在代码中硬编码敏感信息
- 使用相对路径而不是绝对路径

### 3. 依赖管理

- 定期更新依赖以修复安全漏洞
- 使用锁定文件固定依赖版本
- 最小化依赖数量减少攻击面

## 九、联系与支持

如有任何问题或建议，请通过以下方式联系：

- GitHub Issues: https://github.com/yourrepository/prompt-helper/issues
- 邮箱: your-email@example.com

我们欢迎各种形式的贡献，包括但不限于：

- 代码贡献
- 文档改进
- 问题报告
- 功能建议

感谢您对Prompt-Helper项目的支持和贡献！ 